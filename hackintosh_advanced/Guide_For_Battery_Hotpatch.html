<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>电池热补丁指南 (Guide for Battery Hotpatch) | XStar-Dev&#39;s Blog</title>
    <meta name="description" content="Enjoy programming and be pleased to share">
    <meta name="generator" content="VuePress 1.3.1">
    
    
    <link rel="preload" href="/assets/css/0.styles.1c117941.css" as="style"><link rel="preload" href="/assets/js/app.132a4ad5.js" as="script"><link rel="preload" href="/assets/js/2.95e26bf5.js" as="script"><link rel="preload" href="/assets/js/8.5445c4e2.js" as="script"><link rel="prefetch" href="/assets/js/10.8ef54cef.js"><link rel="prefetch" href="/assets/js/11.8bf44787.js"><link rel="prefetch" href="/assets/js/12.848c3ebe.js"><link rel="prefetch" href="/assets/js/13.76f98ffa.js"><link rel="prefetch" href="/assets/js/14.6edb86e1.js"><link rel="prefetch" href="/assets/js/15.ac3c4a67.js"><link rel="prefetch" href="/assets/js/16.b9d82f05.js"><link rel="prefetch" href="/assets/js/3.13478820.js"><link rel="prefetch" href="/assets/js/4.2daac6a2.js"><link rel="prefetch" href="/assets/js/5.e4a176ac.js"><link rel="prefetch" href="/assets/js/6.bc7778eb.js"><link rel="prefetch" href="/assets/js/7.80beb563.js"><link rel="prefetch" href="/assets/js/9.bfc00543.js">
    <link rel="stylesheet" href="/assets/css/0.styles.1c117941.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">XStar-Dev's Blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="黑苹果" class="dropdown-title"><span class="title">黑苹果</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/hackintosh_primary/" class="nav-link">
  基础教程
</a></li><li class="dropdown-item"><!----> <a href="/hackintosh_advanced/" class="nav-link router-link-active">
  进阶教程
</a></li></ul></div></div><div class="nav-item"><a href="/blog/" class="nav-link">
  技术杂谈
</a></div><div class="nav-item"><a href="https://www.github.com/XStar-Dev" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="黑苹果" class="dropdown-title"><span class="title">黑苹果</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/hackintosh_primary/" class="nav-link">
  基础教程
</a></li><li class="dropdown-item"><!----> <a href="/hackintosh_advanced/" class="nav-link router-link-active">
  进阶教程
</a></li></ul></div></div><div class="nav-item"><a href="/blog/" class="nav-link">
  技术杂谈
</a></div><div class="nav-item"><a href="https://www.github.com/XStar-Dev" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/hackintosh_advanced/AppleALC_Custom_For_AppleHDA.html" class="sidebar-link">AppleALC 声卡仿冒教程</a></li><li><a href="/hackintosh_advanced/ACPI_Hotpatch_Overview.html" class="sidebar-link">ACPI 热补丁概述</a></li><li><a href="/hackintosh_advanced/Guide_For_Battery_Hotpatch.html" class="active sidebar-link">笔记本电池热补丁教程</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/hackintosh_advanced/Guide_For_Battery_Hotpatch.html#前言" class="sidebar-link">前言</a></li><li class="sidebar-sub-header"><a href="/hackintosh_advanced/Guide_For_Battery_Hotpatch.html#电池-acpi-方法和驱动原理" class="sidebar-link">电池 ACPI 方法和驱动原理</a></li><li class="sidebar-sub-header"><a href="/hackintosh_advanced/Guide_For_Battery_Hotpatch.html#acpi-寄存器映射原理" class="sidebar-link">ACPI 寄存器映射原理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/hackintosh_advanced/Guide_For_Battery_Hotpatch.html#语法解析" class="sidebar-link">语法解析</a></li><li class="sidebar-sub-header"><a href="/hackintosh_advanced/Guide_For_Battery_Hotpatch.html#代码示例与偏移量计算方法" class="sidebar-link">代码示例与偏移量计算方法</a></li></ul></li><li class="sidebar-sub-header"><a href="/hackintosh_advanced/Guide_For_Battery_Hotpatch.html#拆分函数原理" class="sidebar-link">拆分函数原理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/hackintosh_advanced/Guide_For_Battery_Hotpatch.html#_16-位拆分读取-b1b2" class="sidebar-link">16 位拆分读取 B1B2</a></li><li class="sidebar-sub-header"><a href="/hackintosh_advanced/Guide_For_Battery_Hotpatch.html#_32-位拆分读取-b1b4" class="sidebar-link">32 位拆分读取 B1B4</a></li><li class="sidebar-sub-header"><a href="/hackintosh_advanced/Guide_For_Battery_Hotpatch.html#_16-位拆分写入-w16b" class="sidebar-link">16 位拆分写入 W16B</a></li><li class="sidebar-sub-header"><a href="/hackintosh_advanced/Guide_For_Battery_Hotpatch.html#_32-位以上读取-recb-re1b" class="sidebar-link">32 位以上读取 RECB RE1B</a></li><li class="sidebar-sub-header"><a href="/hackintosh_advanced/Guide_For_Battery_Hotpatch.html#_32-位以上写入-wecb-we1b" class="sidebar-link">32 位以上写入 WECB WE1B</a></li></ul></li><li class="sidebar-sub-header"><a href="/hackintosh_advanced/Guide_For_Battery_Hotpatch.html#热补丁方法详解" class="sidebar-link">热补丁方法详解</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/hackintosh_advanced/Guide_For_Battery_Hotpatch.html#搜索寄存器，创建补丁" class="sidebar-link">搜索寄存器，创建补丁</a></li><li class="sidebar-sub-header"><a href="/hackintosh_advanced/Guide_For_Battery_Hotpatch.html#对调用的寄存器进行拆分处理" class="sidebar-link">对调用的寄存器进行拆分处理</a></li><li class="sidebar-sub-header"><a href="/hackintosh_advanced/Guide_For_Battery_Hotpatch.html#添加-osi-判断" class="sidebar-link">添加 _OSI 判断</a></li><li class="sidebar-sub-header"><a href="/hackintosh_advanced/Guide_For_Battery_Hotpatch.html#添加外部引用声明" class="sidebar-link">添加外部引用声明</a></li><li class="sidebar-sub-header"><a href="/hackintosh_advanced/Guide_For_Battery_Hotpatch.html#更名-method-使其失效" class="sidebar-link">更名 Method 使其失效</a></li><li class="sidebar-sub-header"><a href="/hackintosh_advanced/Guide_For_Battery_Hotpatch.html#检查mutex是否已经置0" class="sidebar-link">检查Mutex是否已经置0</a></li></ul></li><li class="sidebar-sub-header"><a href="/hackintosh_advanced/Guide_For_Battery_Hotpatch.html#acpi-特殊处理方案集合" class="sidebar-link">ACPI 特殊处理方案集合</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/hackintosh_advanced/Guide_For_Battery_Hotpatch.html#惠普笔记本-acel-设备禁止" class="sidebar-link">惠普笔记本 ACEL 设备禁止</a></li><li class="sidebar-sub-header"><a href="/hackintosh_advanced/Guide_For_Battery_Hotpatch.html#ecrd-和-ecwt-读写控制" class="sidebar-link">ECRD 和 ECWT 读写控制</a></li></ul></li><li class="sidebar-sub-header"><a href="/hackintosh_advanced/Guide_For_Battery_Hotpatch.html#双电池系统解决方案" class="sidebar-link">双电池系统解决方案</a></li><li class="sidebar-sub-header"><a href="/hackintosh_advanced/Guide_For_Battery_Hotpatch.html#总结" class="sidebar-link">总结</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/hackintosh_advanced/Guide_For_Battery_Hotpatch.html#一些经验" class="sidebar-link">一些经验</a></li><li class="sidebar-sub-header"><a href="/hackintosh_advanced/Guide_For_Battery_Hotpatch.html#如何排查错误" class="sidebar-link">如何排查错误</a></li></ul></li><li class="sidebar-sub-header"><a href="/hackintosh_advanced/Guide_For_Battery_Hotpatch.html#参考来源" class="sidebar-link">参考来源</a></li></ul></li><li><a href="/hackintosh_advanced/Laptop_I2C_Device_GPIO.html" class="sidebar-link">笔记本 I2C 触摸设备 GPIO 中断实现教程</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="电池热补丁指南-guide-for-battery-hotpatch"><a href="#电池热补丁指南-guide-for-battery-hotpatch" class="header-anchor">#</a> 电池热补丁指南 (Guide for Battery Hotpatch)</h1> <h2 id="前言"><a href="#前言" class="header-anchor">#</a> 前言</h2> <blockquote><p>Last Updated : 4th April，2020 Saturday</p></blockquote> <p><strong>为什么笔记本电池需要制作补丁？</strong>： macOS 使用的 ACPI 规范和解析器与常规 PC 不同，当电池驱动向 ACPI 底层发送指令时，如果读写了大于 8 位的寄存器，程序就会发生错误，导致无法获取到数据</p> <p><strong>实现原理</strong>： 1. 将电池 ACPI 方法相关的超过 8 位的寄存器（位于 <code>Field</code> 里面）拆分成若干个 8 位；2. 利用 ACPI 二进制更名使调用这些寄存器的 <code>Method</code>（函数方法）失效，并在新建的电池补丁中重新定义并修改代码实现电池信息的正确读取</p> <p><strong>技术要求</strong>： 具备一定的 ACPI 基础（请参考 OC-little 中的总述部分），会十六进制进制转换和计算（用于计算偏移量和理解拆分函数）。</p> <p><strong>必备工具</strong>： MaciASL、HEX Fiend、Hackintool（可选）。</p> <p><strong>文件准备</strong>：</p> <ul><li>提取原始 <code>ACPI</code> 文件：利用 <code>CLOVER</code> 引导界面的 <code>F4</code> 快捷键提取，文件将保存在 <code>ACPI/origin</code> 里面，你会看到除了 <code>DSDT.aml</code> 以外还有许多其它的 <code>ACPI</code> 文件，通常我们需要用的就是 <code>DSDT.aml</code>，少数机器需要用到其它的一些 <code>SSDT-xxx.aml</code> 文件。</li> <li>下载参考示例文件及模板文件，链接：<a href="https://pan.baidu.com/s/1hMfz7ayJlRx_JwqqPiebHg" target="_blank" rel="noopener noreferrer">https://pan.baidu.com/s/1hMfz7ayJlRx_JwqqPiebHg<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 提取码: 4wg7</li></ul> <div class="custom-block tip"><p class="custom-block-title">提示</p> <p>大部分笔记本的 EC 代码在 <code>DSDT.aml</code> 中，但也存在例外，如联想拯救者 14ISK/15ISK 的 EC 代码就在 <code>SSDT-1-CB-01.aml</code> 中，本教程所使用的案例就是属于这种情况。</p></div> <h2 id="电池-acpi-方法和驱动原理"><a href="#电池-acpi-方法和驱动原理" class="header-anchor">#</a> 电池 ACPI 方法和驱动原理</h2> <p>打开你的 <code>DSDT.aml</code>（本教程示例使用的为 <code>SSDT-1-CB-01.aml</code>），搜索 <code>PNP0C0A</code>，即可找到电池设备的定义和相关代码 ，且 BIOS 设备名称通常为 <code>BAT0</code> 或者 <code>BAT1</code>，如下所示</p> <div class="language-Swift extra-class"><pre class="language-swift"><code><span class="token builtin">Device</span> <span class="token punctuation">(</span><span class="token builtin">BAT0</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token builtin">Name</span> <span class="token punctuation">(</span><span class="token constant">_HID</span><span class="token punctuation">,</span> <span class="token builtin">EisaId</span> <span class="token punctuation">(</span><span class="token string">&quot;PNP0C0A&quot;</span><span class="token punctuation">)</span> <span class="token comment">/* Control Method Battery */</span><span class="token punctuation">)</span>  <span class="token comment">// _HID: Hardware ID</span>
</code></pre></div><p>在电池 ACPI 代码中，通常具备以下方法，具体解释如下</p> <ul><li><code>_BIF</code> (Battery Information) 用于获取电池基本信息，包括设计容量、电池代号、序列号、电池类型、OEM信息等</li> <li><code>_BIX</code> (Battery Information Extended) 是 <code>_BIF</code> 的拓展方法，电池驱动通常优先使用 <code>_BIX</code> 方法获取电池信息，但是并不是所有笔记本的 ACPI 都具备该方法</li> <li><code>_BST</code> (Battery Status) 用于获取电池实时状态，返回电池充电状态、剩余容量百分比和数值以及当前电池电压</li> <li><code>_BIP</code> (Battery Trip Point) 用于设置电池低电量触发值，大部分电池不支持此功能，这种情况下系统会轮询 <code>_BST</code> 中的剩余电量来判断是否处于警戒水平</li></ul> <p>电池驱动原理：明确电池 ACPI 方法的功能后，我们能够知道电池驱动主要是通过操作 <code>_BIF</code> 和 <code>_BST</code> 这两个方法分别获取电池信息和电池状态的。</p> <blockquote><p>现在常用的电池驱动为 <code>ACPIBatteryManager</code> 和 <code>SMCBatteryManager</code> ，其中前者为 <code>Rehabman</code> 大神开发的驱动，尽管已经不再更新，但是对于部分机器而言更适合使用。</p></blockquote> <h2 id="acpi-寄存器映射原理"><a href="#acpi-寄存器映射原理" class="header-anchor">#</a> ACPI 寄存器映射原理</h2> <ul><li>名词解释：给已经分配好地址的有特定功能的内存单元取一个别名，这样的过程叫寄存器映射，这个别名就是我们常说的寄存器。</li> <li>ACPI 实现方法：通过 <code>OperationRegion</code> 指定作用域（即被映射区域），并在 <code>Field</code> 中指定寄存器的偏移量、长度和名称，使其能够取出被映射区域中的指定数据</li></ul> <p>打开你的 <code>DSDT.aml</code>（本教程示例中位于 <code>DSDT.aml</code> ），搜索 <code>PNP0C09</code>，即可找到 EC 设备的路径，EC 设备的定义代码如下所示</p> <div class="language-Swift extra-class"><pre class="language-swift"><code><span class="token builtin">Scope</span> <span class="token punctuation">(</span><span class="token constant">_SB</span><span class="token punctuation">.</span><span class="token builtin">PCI0</span><span class="token punctuation">.</span><span class="token constant">LPCB</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token builtin">Device</span> <span class="token punctuation">(</span><span class="token constant">H_EC</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token builtin">Name</span> <span class="token punctuation">(</span><span class="token constant">_HID</span><span class="token punctuation">,</span> <span class="token builtin">EisaId</span> <span class="token punctuation">(</span><span class="token string">&quot;PNP0C09&quot;</span><span class="token punctuation">)</span> <span class="token comment">/* Embedded Controller Device */</span><span class="token punctuation">)</span>  <span class="token comment">// _HID: Hardware ID</span>
</code></pre></div><blockquote><p>不同机器的 EC 名称不一样，常见的为 <code>EC</code>、<code>EC0</code>、<code>H_EC</code>，戴尔机器通常使用 <code>ECDV</code>，而华为通常使用 <code>HWEC</code>，尽管如此，它们的 <code>_HID</code> 都是 <code>PNP0C09</code>，这也就是为什么我们选择搜索这个关键词的原因</p></blockquote> <p>上述示例代码中可以看出 EC 的 ACPI 路径为 <code>_SB.PCI0.LPCB.H_EC</code>，我们需要寻找位于该范围下 <code>OperationRegion</code> 和 <code>Field</code></p> <h3 id="语法解析"><a href="#语法解析" class="header-anchor">#</a> 语法解析</h3> <div class="language-Swift extra-class"><pre class="language-swift"><code><span class="token builtin">OperationRegion</span> <span class="token punctuation">(</span><span class="token builtin">RegionName</span><span class="token punctuation">,</span> <span class="token builtin">RegionSpace</span><span class="token punctuation">,</span> <span class="token builtin">Offset</span><span class="token punctuation">,</span> <span class="token builtin">Length</span><span class="token punctuation">)</span>
</code></pre></div><ul><li>RegionName： 操作区名称，EC 下的通常为 <code>ERAM</code>、<code>ECF2</code>、<code>ECF3</code>、<code>ECOR</code> 等，并且有的机器可能不止一个。</li> <li>RegionSpace： 操作空间，又称作用域，通常 EC 使用的作用域都是 <code>EmbeddedControl</code>，但是对于某些厂商，他们会选择将 EC 数据映射到系统内存中，因此作用域为 <code>SystemMemory</code>。</li> <li>Offset： 作用域内每个 Field 的起始偏移量，EC 作用域的起始偏移量通常为 <code>Zero</code>，而系统内存作用域中用于映射 EC 数据的起始偏移量值由厂商决定</li> <li>Length： 作用域内每个 Field 的最大长度。</li></ul> <div class="language-Swift extra-class"><pre class="language-swift"><code><span class="token builtin">Field</span> <span class="token punctuation">(</span><span class="token builtin">RegionName</span><span class="token punctuation">,</span> <span class="token builtin">AccessType</span><span class="token punctuation">,</span> <span class="token builtin">LockRule</span><span class="token punctuation">,</span> <span class="token builtin">UpdateRule</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token builtin">FieldUnitList</span><span class="token punctuation">}</span>
</code></pre></div><ul><li>RegionName：对应 OperationRegion 的操作区名称。</li> <li>AccessType：访问类型，EmbeddedControl 只能是 <code>ByteAcc</code>，代表按字节访问，因此偏移量是以字节来计算的，即每 8 位进 1 。</li> <li>LockRule：锁定规则，与多线程相关，通常为 <code>NoLock</code>。</li> <li>UpdateRule：更新规则，用来指定如何处理未产生改动的映射区域，通常为 <code>Preserve</code>，即维持原值。</li> <li>FieldUnitList：字段单元列表，即寄存器列表，参考下方的示例</li></ul> <h3 id="代码示例与偏移量计算方法"><a href="#代码示例与偏移量计算方法" class="header-anchor">#</a> 代码示例与偏移量计算方法</h3> <ul><li>Field 中每一行的元素由两部分组成，寄存器名称和寄存器长度（单位为 Bit）</li> <li>Offset 用于指定一系列相邻寄存器的起始偏移量，计算机在访问时将通过第一个寄存器的 Offset 和后续寄存器的长度自动确认每个寄存器的偏移量，在后面的热补丁制作中这将是一大重点和难点</li></ul> <div class="language-Swift extra-class"><pre class="language-swift"><code><span class="token builtin">OperationRegion</span> <span class="token punctuation">(</span><span class="token builtin">ECF3</span><span class="token punctuation">,</span> <span class="token builtin">EmbeddedControl</span><span class="token punctuation">,</span> <span class="token builtin">Zero</span><span class="token punctuation">,</span> <span class="token number">0xFF</span><span class="token punctuation">)</span> <span class="token comment">// 作用域为 EmbeddedControl，起始偏移量为0，最大长度 0xFF，即 255个字节</span>
<span class="token builtin">Field</span> <span class="token punctuation">(</span><span class="token builtin">ECF3</span><span class="token punctuation">,</span> <span class="token builtin">ByteAcc</span><span class="token punctuation">,</span> <span class="token builtin">Lock</span><span class="token punctuation">,</span> <span class="token builtin">Preserve</span><span class="token punctuation">)</span> <span class="token comment">// 按字节访问，即每 8 位进 1（1 Byte = 8 Bits）</span>
<span class="token punctuation">{</span>
    <span class="token constant">VCMD</span><span class="token punctuation">,</span>   <span class="token number">8</span><span class="token punctuation">,</span> <span class="token comment">// 0x01</span>
    <span class="token constant">VDAT</span><span class="token punctuation">,</span>   <span class="token number">8</span><span class="token punctuation">,</span> <span class="token comment">// 0x02</span>
    <span class="token constant">VSTA</span><span class="token punctuation">,</span>   <span class="token number">8</span><span class="token punctuation">,</span> <span class="token comment">// 0x03</span>
    <span class="token builtin">Offset</span> <span class="token punctuation">(</span><span class="token number">0x04</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token constant">AIND</span><span class="token punctuation">,</span>   <span class="token number">8</span><span class="token punctuation">,</span> <span class="token comment">// 0x05</span>
    <span class="token constant">ANUM</span><span class="token punctuation">,</span>   <span class="token number">8</span><span class="token punctuation">,</span> <span class="token comment">// 0x06</span>
    <span class="token builtin">F1PW</span><span class="token punctuation">,</span>   <span class="token number">8</span><span class="token punctuation">,</span> <span class="token comment">// 0x07</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token builtin">Offset</span> <span class="token punctuation">(</span><span class="token number">0x60</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token builtin">B1CH</span><span class="token punctuation">,</span>   <span class="token number">32</span><span class="token punctuation">,</span> <span class="token comment">// 0x64 = 0x60 + 0x04 (32/8 = 4 to HEX)</span>
    <span class="token builtin">B2CH</span><span class="token punctuation">,</span>   <span class="token number">32</span><span class="token punctuation">,</span> <span class="token comment">// 0x68</span>
    <span class="token builtin">B1MO</span><span class="token punctuation">,</span>   <span class="token number">16</span><span class="token punctuation">,</span> <span class="token comment">// 0x6A</span>
    <span class="token builtin">B2MO</span><span class="token punctuation">,</span>   <span class="token number">16</span><span class="token punctuation">,</span> <span class="token comment">// 0x6C</span>
    <span class="token builtin">B1SN</span><span class="token punctuation">,</span>   <span class="token number">16</span><span class="token punctuation">,</span> <span class="token comment">// 0x6E</span>
    <span class="token builtin">B2SN</span><span class="token punctuation">,</span>   <span class="token number">16</span><span class="token punctuation">,</span> <span class="token comment">// 0x70</span>
    <span class="token builtin">B1DT</span><span class="token punctuation">,</span>   <span class="token number">16</span><span class="token punctuation">,</span> <span class="token comment">// 0x72</span>
    <span class="token builtin">B2DT</span><span class="token punctuation">,</span>   <span class="token number">16</span><span class="token punctuation">,</span> <span class="token comment">// 0x74</span>
    <span class="token builtin">B1CY</span><span class="token punctuation">,</span>   <span class="token number">16</span><span class="token punctuation">,</span> <span class="token comment">// 0x76</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token builtin">Offset</span> <span class="token punctuation">(</span><span class="token number">0xC2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token constant">BARC</span><span class="token punctuation">,</span>   <span class="token number">16</span><span class="token punctuation">,</span> <span class="token comment">// 0xC4 = 0xC2 + 0x02 (16/8 = 2 to HEX)</span>
    <span class="token constant">BADC</span><span class="token punctuation">,</span>   <span class="token number">16</span><span class="token punctuation">,</span> <span class="token comment">// 0xC6</span>
    <span class="token constant">BADV</span><span class="token punctuation">,</span>   <span class="token number">16</span><span class="token punctuation">,</span> <span class="token comment">// 0xC8</span>
    <span class="token constant">BDCW</span><span class="token punctuation">,</span>   <span class="token number">16</span><span class="token punctuation">,</span> <span class="token comment">// 0xCA</span>
    <span class="token constant">BDCL</span><span class="token punctuation">,</span>   <span class="token number">16</span><span class="token punctuation">,</span> <span class="token comment">// 0xCC</span>
    <span class="token constant">BAFC</span><span class="token punctuation">,</span>   <span class="token number">16</span><span class="token punctuation">,</span> <span class="token comment">// 0xCE</span>
    <span class="token constant">BAPR</span><span class="token punctuation">,</span>   <span class="token number">16</span><span class="token punctuation">,</span> <span class="token comment">// 0xD0</span>
    <span class="token builtin">B1CR</span><span class="token punctuation">,</span>   <span class="token number">16</span><span class="token punctuation">,</span> <span class="token comment">// 0xD2</span>
    <span class="token builtin">B1AR</span><span class="token punctuation">,</span>   <span class="token number">16</span><span class="token punctuation">,</span> <span class="token comment">// 0xD4</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

<span class="token punctuation">}</span>
</code></pre></div><h2 id="拆分函数原理"><a href="#拆分函数原理" class="header-anchor">#</a> 拆分函数原理</h2> <ul><li>将所有大于 8 位的寄存器拆分为若干个 8 位寄存器，如 16 位拆分为 2 个 8 位，32 位拆分为 4 个 8 位，48 位拆分为 6 个 8 位，依次类推</li> <li>寄存器本身的作用没有发生改变，改变的只是每个寄存器存取数据的大小</li> <li>本节只是对拆分函数的原理进行解释，相关的应用示例请参见下一节-热补丁制作详解</li></ul> <div class="custom-block tip"><p class="custom-block-title">注意</p> <p>在处理小于等于 32 位的寄存器时，需要在热补丁中的 EC 范围下创建一个新的操作区为拆分后的寄存器重新映射，具体将在后面的热补丁制作中详细解释</p></div> <h3 id="_16-位拆分读取-b1b2"><a href="#_16-位拆分读取-b1b2" class="header-anchor">#</a> 16 位拆分读取 B1B2</h3> <div class="language-Swift extra-class"><pre class="language-swift"><code><span class="token builtin">Method</span> <span class="token punctuation">(</span><span class="token builtin">B1B2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token builtin">NotSerialized</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token builtin">Return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token builtin">Arg0</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token builtin">Arg1</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token number">0x08</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>参数解释</strong>：<code>Arg0</code> 和 <code>Arg1</code> 为你拆分后的两个8位寄存器，请按照 <code>Field</code> 中的顺序填写参数，如果 <code>Arg1</code> 在 <code>Field</code> 中处在 <code>Arg0</code> 前面，最后拼接的数据将是错误的</p> <p><strong>函数原理</strong>：取 <code>Arg0</code> 作为低 8 位，将 <code>Arg1</code> 运用左移运算变成 16 位数据，此时它的的低 8 位全是 0 ，再运用或运算拼接成完整的 16 位数据</p> <h3 id="_32-位拆分读取-b1b4"><a href="#_32-位拆分读取-b1b4" class="header-anchor">#</a> 32 位拆分读取 B1B4</h3> <div class="language-Swift extra-class"><pre class="language-swift"><code><span class="token builtin">Method</span> <span class="token punctuation">(</span><span class="token builtin">B1B4</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token builtin">NotSerialized</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token builtin">Local0</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token builtin">Arg2</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token builtin">Arg3</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token number">0x08</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token builtin">Local0</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token builtin">Arg1</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token builtin">Local0</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token number">0x08</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token builtin">Local0</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token builtin">Arg0</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token builtin">Local0</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token number">0x08</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token builtin">Return</span> <span class="token punctuation">(</span><span class="token builtin">Local0</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>提示</strong>：原理基本和 <code>B1B2</code> 是一样的，唯一的区别就是此时变成将 4 个 8 位数据拼成 32 位数据了</p> <h3 id="_16-位拆分写入-w16b"><a href="#_16-位拆分写入-w16b" class="header-anchor">#</a> 16 位拆分写入 W16B</h3> <div class="language-Swift extra-class"><pre class="language-swift"><code><span class="token builtin">Method</span> <span class="token punctuation">(</span><span class="token builtin">W16B</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token builtin">NotSerialized</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token builtin">Arg0</span> <span class="token operator">=</span> <span class="token builtin">Arg2</span>
    <span class="token builtin">Arg1</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token builtin">Arg2</span> <span class="token operator">&gt;</span><span class="token operator">&gt;</span> <span class="token number">0x08</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>参数解释</strong>：<code>Arg0</code> 和 <code>Arg1</code> 为你拆分的两个 8 位寄存器，<code>Arg2</code> 为需要写入的数据或对象</p> <p><strong>函数原理</strong>：将 <code>Arg2</code> 直接赋值于 <code>Arg0</code>，此时计算机会将 <code>Arg2</code> 的低 8 位给 <code>Arg0</code>；然后将 <code>Arg2</code> 进行右移计算，将高 8 位数据变为低 8 位数据，同样直接赋值</p> <div class="custom-block tip"><p class="custom-block-title">注意</p> <p>对于大于 32 位的寄存器，我们不在新建的操作区里面进行拆分，而将它交给我们的自定义函数进行自动化处理，具体如下</p></div> <h3 id="_32-位以上读取-recb-re1b"><a href="#_32-位以上读取-recb-re1b" class="header-anchor">#</a> 32 位以上读取 RECB RE1B</h3> <div class="language-Swift extra-class"><pre class="language-swift"><code><span class="token builtin">Method</span> <span class="token punctuation">(</span><span class="token builtin">RE1B</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token builtin">NotSerialized</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token builtin">OperationRegion</span> <span class="token punctuation">(</span><span class="token builtin">ERM2</span><span class="token punctuation">,</span> <span class="token builtin">EmbeddedControl</span><span class="token punctuation">,</span> <span class="token builtin">Arg0</span><span class="token punctuation">,</span> <span class="token builtin">One</span><span class="token punctuation">)</span> <span class="token comment">// 作用域为 EmbeddedControl，Arg0 定义起始偏移量</span>
    <span class="token builtin">Field</span> <span class="token punctuation">(</span><span class="token builtin">ERM2</span><span class="token punctuation">,</span> <span class="token builtin">ByteAcc</span><span class="token punctuation">,</span> <span class="token builtin">NoLock</span><span class="token punctuation">,</span> <span class="token builtin">Preserve</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token constant">BYTE</span><span class="token punctuation">,</span>   <span class="token number">8</span> <span class="token comment">// 指定一个 8 位寄存器映射对应区域数据</span>
    <span class="token punctuation">}</span>

    <span class="token builtin">Return</span> <span class="token punctuation">(</span><span class="token constant">BYTE</span><span class="token punctuation">)</span> <span class="token comment">// 返回结果</span>
<span class="token punctuation">}</span>

<span class="token builtin">Method</span> <span class="token punctuation">(</span><span class="token constant">RECB</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token builtin">Serialized</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token builtin">Arg1</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token builtin">Arg1</span> <span class="token operator">+</span> <span class="token number">0x07</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span><span class="token operator">&gt;</span> <span class="token number">0x03</span><span class="token punctuation">)</span> <span class="token comment">// 计算 Arg1 除 8 并向上取整，位移运算更快</span>
    <span class="token builtin">Name</span> <span class="token punctuation">(</span><span class="token constant">TEMP</span><span class="token punctuation">,</span> <span class="token builtin">Buffer</span> <span class="token punctuation">(</span><span class="token builtin">Arg1</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment">// 初始化作为返回值的 Buffer</span>
    <span class="token builtin">Arg1</span> <span class="token operator">+</span><span class="token operator">=</span> <span class="token builtin">Arg0</span> <span class="token comment">// 加上偏移量，即循环终止值</span>
    <span class="token builtin">Local0</span> <span class="token operator">=</span> <span class="token builtin">Zero</span> <span class="token comment">// 定义 Buffer 索引为 0</span>
    <span class="token builtin">While</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token builtin">Arg0</span> <span class="token operator">&lt;</span> <span class="token builtin">Arg1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 进行循环，循环次数为初次计算的 Arg1，自行理解</span>
    <span class="token punctuation">{</span>
        <span class="token constant">TEMP</span> <span class="token punctuation">[</span><span class="token builtin">Local0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">RE1B</span> <span class="token punctuation">(</span><span class="token builtin">Arg0</span><span class="token punctuation">)</span> <span class="token comment">// 调用 RE1B 依次返回 8 位数据</span>
        <span class="token builtin">Arg0</span><span class="token operator">++</span> <span class="token comment">// 偏移量自增</span>
        <span class="token builtin">Local0</span><span class="token operator">++</span> <span class="token comment">// 索引自增</span>
    <span class="token punctuation">}</span>

    <span class="token builtin">Return</span> <span class="token punctuation">(</span><span class="token constant">TEMP</span><span class="token punctuation">)</span> <span class="token comment">// 返回最终结果</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>参数解释</strong>：</p> <ul><li>对于 <code>RECB</code>，<code>Arg0</code> 是原寄存器的偏移量（即 <code>Offset</code>），<code>Arg1</code> 是原寄存器的长度</li> <li>对于 <code>RE1B</code>，<code>Arg0</code> 是偏移量</li></ul> <p><strong>函数原理</strong>：<code>RECB</code> 通过 <code>Arg1</code> 确定需要拆分的 8 位寄存器个数，通过 <code>While</code> 循环及偏移量自增方法调用 <code>RE1B</code> 从 <code>Field</code> 中循环读取出每个 8 位数据，并拼接成原始寄存器定义长度的数据返回结果，具体见上述代码注释</p> <h3 id="_32-位以上写入-wecb-we1b"><a href="#_32-位以上写入-wecb-we1b" class="header-anchor">#</a> 32 位以上写入 WECB WE1B</h3> <div class="language-Swift extra-class"><pre class="language-swift"><code><span class="token builtin">Method</span> <span class="token punctuation">(</span><span class="token builtin">WE1B</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token builtin">NotSerialized</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token builtin">OperationRegion</span> <span class="token punctuation">(</span><span class="token builtin">ERM2</span><span class="token punctuation">,</span> <span class="token builtin">EmbeddedControl</span><span class="token punctuation">,</span> <span class="token builtin">Arg0</span><span class="token punctuation">,</span> <span class="token builtin">One</span><span class="token punctuation">)</span> <span class="token comment">// EmbeddedControl 为 EC 作用域，Arg0 定义起始偏移量</span>
    <span class="token builtin">Field</span> <span class="token punctuation">(</span><span class="token builtin">ERM2</span><span class="token punctuation">,</span> <span class="token builtin">ByteAcc</span><span class="token punctuation">,</span> <span class="token builtin">NoLock</span><span class="token punctuation">,</span> <span class="token builtin">Preserve</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token constant">BYTE</span><span class="token punctuation">,</span>   <span class="token number">8</span> <span class="token comment">// 指定一个 8 位寄存器映射对应区域数据</span>
    <span class="token punctuation">}</span>

    <span class="token constant">BYTE</span> <span class="token operator">=</span> <span class="token builtin">Arg1</span> <span class="token comment">// 将 Arg1 通过寄存器间接写入对应区域</span>
<span class="token punctuation">}</span>

<span class="token builtin">Method</span> <span class="token punctuation">(</span><span class="token constant">WECB</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token builtin">Serialized</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token builtin">Arg1</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token builtin">Arg1</span> <span class="token operator">+</span> <span class="token number">0x07</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span><span class="token operator">&gt;</span> <span class="token number">0x03</span><span class="token punctuation">)</span> <span class="token comment">// 计算 Arg1 除 8 并向上取整，位移运算更快</span>
    <span class="token builtin">Name</span> <span class="token punctuation">(</span><span class="token constant">TEMP</span><span class="token punctuation">,</span> <span class="token builtin">Buffer</span> <span class="token punctuation">(</span><span class="token builtin">Arg1</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment">// 初始化作为写入值的 Buffer</span>
    <span class="token constant">TEMP</span> <span class="token operator">=</span> <span class="token builtin">Arg2</span> <span class="token comment">// 将被写入的数据或对象赋值给 TEMP</span>
    <span class="token builtin">Arg1</span> <span class="token operator">+</span><span class="token operator">=</span> <span class="token builtin">Arg0</span> <span class="token comment">// 加上偏移量，即循环终止值</span>
    <span class="token builtin">Local0</span> <span class="token operator">=</span> <span class="token builtin">Zero</span> <span class="token comment">// 定义 Buffer 索引为 0</span>
    <span class="token builtin">While</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token builtin">Arg0</span> <span class="token operator">&lt;</span> <span class="token builtin">Arg1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 进行循环，循环次数为初次计算的 Arg1，自行理解</span>
    <span class="token punctuation">{</span>
        <span class="token builtin">WE1B</span> <span class="token punctuation">(</span><span class="token builtin">Arg0</span><span class="token punctuation">,</span> <span class="token builtin">DerefOf</span> <span class="token punctuation">(</span><span class="token constant">TEMP</span> <span class="token punctuation">[</span><span class="token builtin">Local0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 调用 WE1B 依次写入 8 位数据</span>
        <span class="token builtin">Arg0</span><span class="token operator">++</span> <span class="token comment">// 偏移量自增</span>
        <span class="token builtin">Local0</span><span class="token operator">++</span> <span class="token comment">// 索引自增</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>参数解释</strong>：</p> <ul><li>对于 <code>WECB</code>，<code>Arg0</code> 是原寄存器的偏移量（即 <code>Offset</code>），<code>Arg1</code> 是原寄存器的长度，<code>Arg2</code> 为被写入的数据或对象</li> <li>对于 <code>WE1B</code>，<code>Arg0</code> 是偏移量，<code>Arg1</code> 为从 Buffer 取出的一个字节数据（即 8 位长度数据）</li></ul> <p><strong>函数原理</strong>：<code>WECB</code> 通过 <code>Arg1</code> 确定需要拆分的 8 位寄存器个数，创建 Buffer 对象将 <code>Arg2</code> 转化为若干个字节的数据（一个字节等于 8 位），通过 <code>While</code> 循环以及偏移量自增方法调用 <code>WE1B</code>，向 <code>Field</code> 中循环写入每个 8 位数据，具体见上述代码注释</p> <div class="custom-block warning"><p class="custom-block-title">注意</p> <p>有些笔记本的 <code>EC</code> 使用 <code>SystemMemory</code> 作用域，则 <code>EC</code>、<code>RE1B</code> 和 <code>WE1B</code> 的 <code>Field</code> 起始偏移量也需要加上原始定义数值，参照如下所示代码进行修改</p></div> <div class="language-Swift extra-class"><pre class="language-swift"><code><span class="token builtin">Scope</span> <span class="token punctuation">(</span><span class="token constant">_SB</span><span class="token punctuation">.</span><span class="token builtin">PCI0</span><span class="token punctuation">.</span><span class="token constant">LPCB</span><span class="token punctuation">.</span><span class="token builtin">EC0</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token builtin">OperationRegion</span> <span class="token punctuation">(</span><span class="token constant">ERAX</span><span class="token punctuation">,</span> <span class="token builtin">SystemMemory</span><span class="token punctuation">,</span> <span class="token number">0xFE708300</span><span class="token punctuation">,</span> <span class="token number">0x0100</span><span class="token punctuation">)</span>
    <span class="token builtin">Field</span> <span class="token punctuation">(</span><span class="token constant">ERAX</span><span class="token punctuation">,</span> <span class="token builtin">ByteAcc</span><span class="token punctuation">,</span> <span class="token builtin">Lock</span><span class="token punctuation">,</span> <span class="token builtin">Preserve</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
    ···
    <span class="token builtin">Method</span> <span class="token punctuation">(</span><span class="token builtin">RE1B</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token builtin">NotSerialized</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token builtin">Local0</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">0xFE708300</span> <span class="token operator">+</span> <span class="token builtin">Arg0</span><span class="token punctuation">)</span>
        <span class="token builtin">OperationRegion</span> <span class="token punctuation">(</span><span class="token builtin">ERM2</span><span class="token punctuation">,</span> <span class="token builtin">SystemMemory</span><span class="token punctuation">,</span> <span class="token builtin">Local0</span><span class="token punctuation">,</span> <span class="token builtin">One</span><span class="token punctuation">)</span>
</code></pre></div><h2 id="热补丁方法详解"><a href="#热补丁方法详解" class="header-anchor">#</a> 热补丁方法详解</h2> <blockquote><p>如果你有认真学习和理解拆分函数的原理，相信接下来的步骤将会进行起来非常顺利</p></blockquote> <h3 id="搜索寄存器，创建补丁"><a href="#搜索寄存器，创建补丁" class="header-anchor">#</a> 搜索寄存器，创建补丁</h3> <p>在 ACPI 寄存器映射原理中，我已经介绍了如何确认 EC 路径以及各拆分函数的原理和语法解释，接下来我们需要在 EC 下寻找所有的 <code>OperationRegion</code> 和 <code>Field</code>，并从中筛选出超过 8 位的寄存器</p> <ul><li>根据每个 <code>OperationRegion</code> 的操作区名称找到所有对应的 <code>Field</code>，筛选超过 8 位的寄存器，并检查是否存在被调用的情况。</li> <li>若存在被调用的情况，对应源代码的情况，按顺序排列需要拆分的寄存器（当存在多个 <code>Field</code> 里面的寄存器需要拆分时请分组排列，便于后续处理），并注明它们的长度。</li> <li>计算它们的偏移量，如果是几个连续的寄存器，只需要计算第一个的偏移量，因为相邻的寄存器都是按顺序进行操作的，不需要额外计算。</li></ul> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>如果某个寄存器被全局定义过，例如在根路径（<code>\</code>）或者（<code>\_SB</code>）路径下的 <code>Field</code> 里面有相同名字的寄存器，那么当你搜索该寄存器被调用情况时应注意区分此处的调用是不是 EC 下的这一个，如果不是，说明此处调用使用的是全局定义，对 EC 没有影响，不需要记录下来。</p></div> <p>对照我们的示例文件，整理记录如下</p> <p><strong>16位</strong>： <code>B1DT</code>，<code>B1CY</code>，<code>RTEP</code>，<code>BET2</code>，<code>B1TM</code>，<code>BAPV</code>，<code>BARC</code>，<code>BADC</code>，<code>BADV</code>，<code>BAFC</code>，<code>B1CR</code></p> <p><strong>32位</strong>： <code>B1CH</code></p> <p><strong>大于32位</strong>： <code>SMD0, 256</code>，<code>B1MA, 64</code>，<code>B2MA, 64</code></p> <p><strong>需要修改的 Method</strong>：</p> <ul><li><code>_SB.PCI0.LPCB.H_EC.BAT1._BIF</code></li> <li><code>_SB.PCI0.LPCB.H_EC.BAT1._BST</code></li> <li><code>_SB.PCI0.LPCB.H_EC.VPC0.MHPF</code></li> <li><code>_SB.PCI0.LPCB.H_EC.VPC0.SMTF</code></li> <li><code>_SB.PCI0.LPCB.H_EC.VPC0.GSBI</code></li> <li><code>_SB.PCI0.LPCB.H_EC.VPC0.GBID</code></li></ul> <p>打开模板文件 <code>SSDT-BATT.dsl</code>，在 EC 路径的 <code>Scope</code> 下（请务必修改为自己的 EC 设备路径），创建 <code>OperationRegion</code> 和 <code>Field</code>，将已经拆分命名并计算好偏移量的寄存器填入代码中，示例如下：</p> <div class="language-Swift extra-class"><pre class="language-swift"><code><span class="token builtin">OperationRegion</span> <span class="token punctuation">(</span><span class="token builtin">XCF3</span><span class="token punctuation">,</span> <span class="token builtin">EmbeddedControl</span><span class="token punctuation">,</span> <span class="token builtin">Zero</span><span class="token punctuation">,</span> <span class="token number">0xFF</span><span class="token punctuation">)</span>
<span class="token builtin">Field</span> <span class="token punctuation">(</span><span class="token builtin">XCF3</span><span class="token punctuation">,</span> <span class="token builtin">ByteAcc</span><span class="token punctuation">,</span> <span class="token builtin">NoLock</span><span class="token punctuation">,</span> <span class="token builtin">Preserve</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token builtin">Offset</span> <span class="token punctuation">(</span><span class="token number">0x60</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token builtin">BC0H</span><span class="token punctuation">,</span>   <span class="token number">8</span><span class="token punctuation">,</span>
    <span class="token builtin">BC1H</span><span class="token punctuation">,</span>   <span class="token number">8</span><span class="token punctuation">,</span>
    <span class="token builtin">BC2H</span><span class="token punctuation">,</span>   <span class="token number">8</span><span class="token punctuation">,</span>
    <span class="token builtin">BC3H</span><span class="token punctuation">,</span>   <span class="token number">8</span><span class="token punctuation">,</span>
    <span class="token builtin">Offset</span> <span class="token punctuation">(</span><span class="token number">0x70</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token builtin">BDT0</span><span class="token punctuation">,</span>   <span class="token number">8</span><span class="token punctuation">,</span>
    <span class="token builtin">BDT1</span><span class="token punctuation">,</span>   <span class="token number">8</span><span class="token punctuation">,</span>
    <span class="token builtin">Offset</span> <span class="token punctuation">(</span><span class="token number">0x74</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token builtin">BCY0</span><span class="token punctuation">,</span>   <span class="token number">8</span><span class="token punctuation">,</span>
    <span class="token builtin">BCY1</span><span class="token punctuation">,</span>   <span class="token number">8</span><span class="token punctuation">,</span>
    <span class="token builtin">Offset</span> <span class="token punctuation">(</span><span class="token number">0xAA</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token builtin">RTP0</span><span class="token punctuation">,</span>   <span class="token number">8</span><span class="token punctuation">,</span>
    <span class="token builtin">RTP1</span><span class="token punctuation">,</span>   <span class="token number">8</span><span class="token punctuation">,</span>
    <span class="token builtin">B0ET</span><span class="token punctuation">,</span>   <span class="token number">8</span><span class="token punctuation">,</span>
    <span class="token builtin">B1ET</span><span class="token punctuation">,</span>   <span class="token number">8</span><span class="token punctuation">,</span>
    <span class="token builtin">Offset</span> <span class="token punctuation">(</span><span class="token number">0xB6</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token builtin">BTM0</span><span class="token punctuation">,</span>   <span class="token number">8</span><span class="token punctuation">,</span>
    <span class="token builtin">BTM1</span><span class="token punctuation">,</span>   <span class="token number">8</span><span class="token punctuation">,</span>
    <span class="token builtin">B0PV</span><span class="token punctuation">,</span>   <span class="token number">8</span><span class="token punctuation">,</span>
    <span class="token builtin">B1PV</span><span class="token punctuation">,</span>   <span class="token number">8</span><span class="token punctuation">,</span>
    <span class="token builtin">Offset</span> <span class="token punctuation">(</span><span class="token number">0xC2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token builtin">BAC0</span><span class="token punctuation">,</span>   <span class="token number">8</span><span class="token punctuation">,</span>
    <span class="token builtin">BAC1</span><span class="token punctuation">,</span>   <span class="token number">8</span><span class="token punctuation">,</span>
    <span class="token builtin">BDC0</span><span class="token punctuation">,</span>   <span class="token number">8</span><span class="token punctuation">,</span>
    <span class="token builtin">BDC1</span><span class="token punctuation">,</span>   <span class="token number">8</span><span class="token punctuation">,</span>
    <span class="token builtin">BDV0</span><span class="token punctuation">,</span>   <span class="token number">8</span><span class="token punctuation">,</span>
    <span class="token builtin">BDV1</span><span class="token punctuation">,</span>   <span class="token number">8</span><span class="token punctuation">,</span>
    <span class="token builtin">Offset</span> <span class="token punctuation">(</span><span class="token number">0xCC</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token builtin">BFC0</span><span class="token punctuation">,</span>   <span class="token number">8</span><span class="token punctuation">,</span>
    <span class="token builtin">BFC1</span><span class="token punctuation">,</span>   <span class="token number">8</span><span class="token punctuation">,</span>
    <span class="token builtin">Offset</span> <span class="token punctuation">(</span><span class="token number">0xD0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token builtin">BCR0</span><span class="token punctuation">,</span>   <span class="token number">8</span><span class="token punctuation">,</span>
    <span class="token builtin">BCR1</span><span class="token punctuation">,</span>   <span class="token number">8</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>上述代码中，为了避免与原始 <code>ACPI</code> 中的操作区映射定义发生冲突，我们创建的操作区名称为 <code>XCF3</code>，区别于原始 <code>ACPI</code> 中的 <code>ECF3</code></p></div> <p><strong>当然，我们对寄存器的拆分也要注意避免重复，比如我把 <code>BADC</code> 拆分为 <code>BAC0</code> 和 <code>BAC1</code>，应该在原始 <code>ACPI</code> 中搜索是否存在同样名字的寄存器，最佳方法是直接在 <code>orgin</code> 目录下打开终端使用 <code>grep</code> 命令搜索，方便快捷。</strong></p> <h3 id="对调用的寄存器进行拆分处理"><a href="#对调用的寄存器进行拆分处理" class="header-anchor">#</a> 对调用的寄存器进行拆分处理</h3> <div class="custom-block tip"><p class="custom-block-title">注意</p> <p>根据我们之前记录的路径将需要修改的 <code>Method</code> 代码完整复制过来，注意大括号千万别复制错了，不然后面排查错误会很麻烦。</p></div> <p><strong>修改 16 位以上寄存器拆分读取</strong>：</p> <p><strong>语法</strong>：</p> <div class="language-Swift extra-class"><pre class="language-swift"><code><span class="token builtin">B1B2</span> <span class="token punctuation">(</span><span class="token builtin">Arg0</span><span class="token punctuation">,</span> <span class="token builtin">Arg1</span><span class="token punctuation">)</span>
</code></pre></div><ul><li><code>Arg0</code>、<code>Arg1</code> 为你拆分后的两个 8 位寄存器名字，注意顺序。</li></ul> <p><strong>示例</strong>：</p> <p>原始语句：</p> <div class="language-Swift extra-class"><pre class="language-swift"><code><span class="token builtin">If</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">^</span><span class="token operator">^</span><span class="token builtin">PCI0</span><span class="token punctuation">.</span><span class="token constant">LPCB</span><span class="token punctuation">.</span><span class="token builtin">EC0</span><span class="token punctuation">.</span><span class="token constant">BADC</span> <span class="token operator">&lt;</span> <span class="token number">0x0C80</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><p>一个比较判断语句，属于读取操作，我将 <code>BADC</code> 拆分为 <code>ADC0</code> 和 <code>ADC1</code>，并进行如下修改：</p> <div class="language-Swift extra-class"><pre class="language-swift"><code><span class="token builtin">If</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token builtin">B1B2</span> <span class="token punctuation">(</span><span class="token operator">^</span><span class="token operator">^</span><span class="token builtin">PCI0</span><span class="token punctuation">.</span><span class="token constant">LPCB</span><span class="token punctuation">.</span><span class="token builtin">EC0</span><span class="token punctuation">.</span><span class="token builtin">ADC0</span><span class="token punctuation">,</span> <span class="token operator">^</span><span class="token operator">^</span><span class="token builtin">PCI0</span><span class="token punctuation">.</span><span class="token constant">LPCB</span><span class="token punctuation">.</span><span class="token builtin">EC0</span><span class="token punctuation">.</span><span class="token builtin">ADC1</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0x0C80</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><p><strong>修改 16 位寄存器拆分写入</strong>：</p> <p><strong>语法</strong>：</p> <div class="language-Swift extra-class"><pre class="language-swift"><code><span class="token builtin">W16B</span> <span class="token punctuation">(</span><span class="token builtin">Arg0</span><span class="token punctuation">,</span> <span class="token builtin">Arg1，Arg2</span><span class="token punctuation">)</span>
</code></pre></div><ul><li><code>Arg0</code>、<code>Arg1</code> 为你拆分后的两个 8 位寄存器名字，注意顺序。</li> <li><code>Arg2</code> 为被写入的数值或数据对象。</li></ul> <p><strong>示例</strong>：</p> <p>原始语句：</p> <div class="language-Swift extra-class"><pre class="language-swift"><code><span class="token builtin">SMW0</span> <span class="token operator">=</span> <span class="token builtin">Arg3</span>
</code></pre></div><p>普通的赋值语句，属于写入数据操作，我将 <code>SMW0</code> 拆分为 <code>MW00</code> 和 <code>MW01</code>，并进行如下修改：</p> <div class="language-Swift extra-class"><pre class="language-swift"><code><span class="token builtin">W16B</span> <span class="token punctuation">(</span><span class="token builtin">MW00</span><span class="token punctuation">,</span> <span class="token builtin">MW01</span><span class="token punctuation">,</span> <span class="token builtin">Arg3</span><span class="token punctuation">)</span>
</code></pre></div><p><strong>修改 32 位寄存器拆分读取</strong>：</p> <p><strong>语法</strong>：</p> <div class="language-Swift extra-class"><pre class="language-swift"><code><span class="token builtin">B1B4</span> <span class="token punctuation">(</span><span class="token builtin">Arg0</span><span class="token punctuation">,</span> <span class="token builtin">Arg1</span><span class="token punctuation">,</span> <span class="token builtin">Arg2</span><span class="token punctuation">,</span> <span class="token builtin">Arg3</span><span class="token punctuation">)</span>
</code></pre></div><ul><li><code>Arg0</code>、<code>Arg1</code>、<code>Arg2</code> 和 <code>Arg3</code> 为你拆分后的 4 个 8 位寄存器名字，注意顺序。</li></ul> <p><strong>示例</strong>：</p> <p>原始语句：</p> <div class="language-Swift extra-class"><pre class="language-swift"><code><span class="token builtin">If</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token builtin">B1CH</span> <span class="token operator">==</span> <span class="token number">0x0050694C</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><p>修改结果：</p> <div class="language-Swift extra-class"><pre class="language-swift"><code><span class="token builtin">If</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token builtin">B1B4</span> <span class="token punctuation">(</span><span class="token builtin">BC0H</span><span class="token punctuation">,</span> <span class="token builtin">BC1H</span><span class="token punctuation">,</span> <span class="token builtin">BC2H</span><span class="token punctuation">,</span> <span class="token builtin">BC3H</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0x0050694C</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><p><strong>修改 32 位以上寄存器读取</strong>：</p> <p><strong>语法</strong>：</p> <div class="language-Swift extra-class"><pre class="language-swift"><code><span class="token constant">RECB</span> <span class="token punctuation">(</span><span class="token builtin">Offset</span><span class="token punctuation">,</span> <span class="token builtin">Length</span><span class="token punctuation">)</span>
</code></pre></div><ul><li>Offset 为原寄存器的偏移量</li> <li>Length 为原寄存器的长度</li></ul> <p><strong>示例</strong>：</p> <p>原始定义：</p> <div class="language-Swift extra-class"><pre class="language-swift"><code><span class="token builtin">Offset</span> <span class="token punctuation">(</span><span class="token number">0x8F</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token builtin">B1MA</span><span class="token punctuation">,</span>   <span class="token number">64</span><span class="token punctuation">,</span>
</code></pre></div><p>调用语句：</p> <div class="language-Swift extra-class"><pre class="language-swift"><code><span class="token constant">IFMN</span> <span class="token operator">=</span> <span class="token builtin">B1MA</span>
</code></pre></div><p>修改结果：</p> <div class="language-Swift extra-class"><pre class="language-swift"><code><span class="token constant">IFMN</span> <span class="token operator">=</span> <span class="token constant">RECB</span> <span class="token punctuation">(</span><span class="token number">0x8F</span><span class="token punctuation">,</span> <span class="token number">0x40</span><span class="token punctuation">)</span>
</code></pre></div><p><strong>修改 32 位以上寄存器写入</strong>：</p> <p><strong>语法</strong>：</p> <div class="language-Swift extra-class"><pre class="language-swift"><code><span class="token constant">WECB</span> <span class="token punctuation">(</span><span class="token builtin">Offset</span><span class="token punctuation">,</span> <span class="token builtin">Length</span><span class="token punctuation">,</span> <span class="token builtin">Obj</span><span class="token punctuation">)</span>
</code></pre></div><ul><li>Offset 为原寄存器的偏移量</li> <li>Length 为寄存器的长度</li> <li>Obj 为被写入的值或者数据对象</li></ul> <p><strong>示例</strong>：</p> <p>原始定义：</p> <div class="language-Swift extra-class"><pre class="language-swift"><code><span class="token builtin">Offset</span> <span class="token punctuation">(</span><span class="token number">0x18</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token constant">SMPR</span><span class="token punctuation">,</span>   <span class="token number">8</span><span class="token punctuation">,</span>
<span class="token constant">SMST</span><span class="token punctuation">,</span>   <span class="token number">8</span><span class="token punctuation">,</span>
<span class="token constant">SMAD</span><span class="token punctuation">,</span>   <span class="token number">8</span><span class="token punctuation">,</span>
<span class="token constant">SMCM</span><span class="token punctuation">,</span>   <span class="token number">8</span><span class="token punctuation">,</span>
<span class="token builtin">SMD0</span><span class="token punctuation">,</span>   <span class="token number">256</span><span class="token punctuation">,</span>
</code></pre></div><p>调用语句：</p> <div class="language-Swift extra-class"><pre class="language-swift"><code><span class="token builtin">SMD0</span> <span class="token operator">=</span> <span class="token builtin">FB4</span>
</code></pre></div><p>修改结果：</p> <div class="language-Swift extra-class"><pre class="language-swift"><code><span class="token constant">WECB</span> <span class="token punctuation">(</span><span class="token number">0x1C</span><span class="token punctuation">,</span> <span class="token number">0x0100</span><span class="token punctuation">,</span> <span class="token builtin">FB4</span><span class="token punctuation">)</span> <span class="token comment">// 0x1C=0x18+0x04</span>
</code></pre></div><h3 id="添加-osi-判断"><a href="#添加-osi-判断" class="header-anchor">#</a> 添加 _OSI 判断</h3> <blockquote><p>OpenCore 在引导时对于任何系统都是加载的同一套 ACPI，我们应确保我们的补丁只对 macOS 生效，此时我们需要通过添加 <code>If(_OSI(&quot;Darwin&quot;)){}</code> 判断的方法使其在其他系统下不生效，避免 OC 在引导其它系统时出现不必要的 ACPI 错误。</p></blockquote> <p>在已经完成的补丁文件中，在每一个 <code>Method</code> 的开始部分加上 <code>_OSI</code> 系统判断并在结尾处回调原始方法，示例如下：</p> <div class="language-Swift extra-class"><pre class="language-swift"><code><span class="token builtin">Method</span> <span class="token punctuation">(</span><span class="token constant">_BIF</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token builtin">NotSerialized</span><span class="token punctuation">)</span>  <span class="token comment">// _BIF: Battery Information</span>
<span class="token punctuation">{</span>
    <span class="token builtin">If</span> <span class="token punctuation">(</span><span class="token constant">_OSI</span> <span class="token punctuation">(</span><span class="token string">&quot;Darwin&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token builtin">Return</span> <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
    <span class="token builtin">Else</span>
    <span class="token punctuation">{</span>
        <span class="token builtin">Return</span> <span class="token punctuation">(</span><span class="token constant">XBIF</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>以上述代码为例 ，<code>Else</code> 后面的代码为回调原始方法，如果原始方法没有出现 <code>Return</code> 语句，则可直接以 <code>XBIF()</code> 的方式回调；如果原始方法的代码中出现了 <code>Return</code> 语句，则在回调时也需要以 <code>Return</code> 形式回调原方法。</p> <p>如果原始方法带参数则应该在回调时将参数传递过去，如下代码：</p> <div class="language-Swift extra-class"><pre class="language-swift"><code><span class="token builtin">Method</span> <span class="token punctuation">(</span><span class="token constant">SMTF</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token builtin">NotSerialized</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token builtin">If</span> <span class="token punctuation">(</span><span class="token constant">_OSI</span> <span class="token punctuation">(</span><span class="token string">&quot;Darwin&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token builtin">If</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token builtin">Arg0</span> <span class="token operator">==</span> <span class="token builtin">Zero</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token builtin">Return</span> <span class="token punctuation">(</span><span class="token builtin">B1B2</span> <span class="token punctuation">(</span><span class="token builtin">B0ET</span><span class="token punctuation">,</span> <span class="token builtin">B1ET</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>

        <span class="token builtin">If</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token builtin">Arg0</span> <span class="token operator">==</span> <span class="token builtin">One</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token builtin">Return</span> <span class="token punctuation">(</span><span class="token builtin">Zero</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>

        <span class="token builtin">Return</span> <span class="token punctuation">(</span><span class="token builtin">Zero</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token builtin">Else</span>
    <span class="token punctuation">{</span>
        <span class="token builtin">Return</span> <span class="token punctuation">(</span><span class="token constant">XMTF</span> <span class="token punctuation">(</span><span class="token builtin">Arg0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>注意：ASL 语言中方法的参数是从 <code>Arg0</code> 开始的。</strong></p> <h3 id="添加外部引用声明"><a href="#添加外部引用声明" class="header-anchor">#</a> 添加外部引用声明</h3> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>在确认修改结束后，我们点击编译会报告许多对象找不到的错误，一般来说，这些错误是由于我们复制过来的代码引用了原始 ACPI 中的一些对象但在 SSDT 中缺少引用声明导致的。在这里我们只需要搜索它们在原始 ACPI 中的定义路径和类型，并在补丁文件头部（介于 <code>DefinitionBlock</code> 和后面的 <code>Method</code> 代码之间）添加上引用声明即可解决大多数编译错误。</p></div> <div class="custom-block warning"><p class="custom-block-title">注意</p> <p>添加外部引用声明时应注意路径和类型应严格对应，参照下列示例</p></div> <p><strong>Device</strong>：原始 ACPI 定义示例</p> <div class="language-Swift extra-class"><pre class="language-swift"><code><span class="token builtin">Scope</span> <span class="token punctuation">(</span><span class="token constant">_SB</span><span class="token punctuation">.</span><span class="token builtin">PCI0</span><span class="token punctuation">.</span><span class="token constant">LPCB</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token builtin">Device</span> <span class="token punctuation">(</span><span class="token constant">H_EC</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
</code></pre></div><p>补丁中添加的代码示例</p> <div class="language-Swift extra-class"><pre class="language-swift"><code><span class="token builtin">External</span> <span class="token punctuation">(</span><span class="token constant">_SB_</span><span class="token punctuation">.</span><span class="token builtin">PCI0</span><span class="token punctuation">.</span><span class="token constant">LPCB</span><span class="token punctuation">.</span><span class="token constant">H_EC</span><span class="token punctuation">,</span> <span class="token builtin">DeviceObj</span><span class="token punctuation">)</span>
</code></pre></div><p><strong>Method</strong>：原始 ACPI 定义示例</p> <div class="language-Swift extra-class"><pre class="language-swift"><code><span class="token builtin">Method</span> <span class="token punctuation">(</span><span class="token constant">_STA</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token builtin">NotSerialized</span><span class="token punctuation">)</span>  <span class="token comment">/* _STA: Status */</span>
</code></pre></div><p>补丁中添加的代码示例</p> <div class="language-Swift extra-class"><pre class="language-swift"><code><span class="token builtin">External</span> <span class="token punctuation">(</span><span class="token constant">_SB_</span><span class="token punctuation">.</span><span class="token builtin">BAT0</span><span class="token punctuation">.</span><span class="token constant">_STA</span><span class="token punctuation">,</span> <span class="token builtin">MethodObj</span><span class="token punctuation">)</span>
</code></pre></div><p><strong>Mutex</strong>：原始 ACPI 定义示例</p> <div class="language-Swift extra-class"><pre class="language-swift"><code><span class="token builtin">Mutex</span> <span class="token punctuation">(</span><span class="token constant">BATM</span><span class="token punctuation">,</span> <span class="token number">0x07</span><span class="token punctuation">)</span>
</code></pre></div><p>补丁中添加的代码示例</p> <div class="language-Swift extra-class"><pre class="language-swift"><code><span class="token builtin">External</span> <span class="token punctuation">(</span><span class="token constant">_SB_</span><span class="token punctuation">.</span><span class="token builtin">PCI0</span><span class="token punctuation">.</span><span class="token constant">LPCB</span><span class="token punctuation">.</span><span class="token constant">H_EC</span><span class="token punctuation">.</span><span class="token constant">BATM</span><span class="token punctuation">,</span> <span class="token builtin">MutexObj</span><span class="token punctuation">)</span>
</code></pre></div><p><strong>FieldUnit</strong>：原始 ACPI 定义示例</p> <div class="language-Swift extra-class"><pre class="language-swift"><code><span class="token function">Field</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token constant">BCNT</span><span class="token punctuation">,</span>   <span class="token number">8</span><span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre></div><p>补丁中添加的代码示例</p> <div class="language-Swift extra-class"><pre class="language-swift"><code><span class="token builtin">External</span> <span class="token punctuation">(</span><span class="token constant">_SB_</span><span class="token punctuation">.</span><span class="token builtin">PCI0</span><span class="token punctuation">.</span><span class="token constant">LPCB</span><span class="token punctuation">.</span><span class="token constant">H_EC</span><span class="token punctuation">.</span><span class="token constant">BCNT</span><span class="token punctuation">,</span> <span class="token builtin">FieldUnitObj</span><span class="token punctuation">)</span>
</code></pre></div><p><strong>Integer</strong>：原始 ACPI 定义示例</p> <div class="language-Swift extra-class"><pre class="language-swift"><code><span class="token builtin">Name</span> <span class="token punctuation">(</span><span class="token builtin">ECA2</span><span class="token punctuation">,</span> <span class="token builtin">Zero</span><span class="token punctuation">)</span>
</code></pre></div><p>补丁中添加的代码示例</p> <div class="language-Swift extra-class"><pre class="language-swift"><code><span class="token builtin">External</span> <span class="token punctuation">(</span><span class="token constant">_SB_</span><span class="token punctuation">.</span><span class="token builtin">PCI0</span><span class="token punctuation">.</span><span class="token constant">LPCB</span><span class="token punctuation">.</span><span class="token constant">H_EC</span><span class="token punctuation">.</span><span class="token builtin">ECA2</span><span class="token punctuation">,</span> <span class="token builtin">IntObj</span><span class="token punctuation">)</span>
</code></pre></div><p><strong>Package</strong>：原始 ACPI 定义示例</p> <div class="language-Swift extra-class"><pre class="language-swift"><code><span class="token builtin">Name</span> <span class="token punctuation">(</span><span class="token constant">PBIF</span><span class="token punctuation">,</span> <span class="token builtin">Package</span> <span class="token punctuation">(</span><span class="token number">0x0D</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token builtin">One</span><span class="token punctuation">,</span>
    <span class="token number">0xFFFFFFFF</span><span class="token punctuation">,</span>
    <span class="token number">0xFFFFFFFF</span><span class="token punctuation">,</span>
    <span class="token builtin">One</span><span class="token punctuation">,</span>
    <span class="token number">0xFFFFFFFF</span><span class="token punctuation">,</span>
    <span class="token number">0xFA</span><span class="token punctuation">,</span>
    <span class="token number">0x96</span><span class="token punctuation">,</span>
    <span class="token number">0x0A</span><span class="token punctuation">,</span>
    <span class="token number">0x19</span><span class="token punctuation">,</span>
    <span class="token string">&quot;BAT0&quot;</span><span class="token punctuation">,</span>
    <span class="token string">&quot; &quot;</span><span class="token punctuation">,</span>
    <span class="token string">&quot; &quot;</span><span class="token punctuation">,</span>
    <span class="token string">&quot; &quot;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>补丁中添加的代码示例</p> <div class="language-Swift extra-class"><pre class="language-swift"><code><span class="token builtin">External</span> <span class="token punctuation">(</span><span class="token constant">_SB_</span><span class="token punctuation">.</span><span class="token builtin">BAT0</span><span class="token punctuation">.</span><span class="token constant">PBIF</span><span class="token punctuation">,</span> <span class="token builtin">PkgObj</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="更名-method-使其失效"><a href="#更名-method-使其失效" class="header-anchor">#</a> 更名 Method 使其失效</h3> <blockquote><p>Hotpatch 的原理是通过 ACPI 二进制更名使原来 ACPI 中的  Method失效，并在新的 SSDT 补丁中重新定义它，以方便我们直接修改里面的代码。</p></blockquote> <ol><li><p>用 MaciASL 查看补丁中修改的 <code>Method</code>，确认它们的参数个数以及是否可序列化（<code>NotSerialized</code> 和 <code>Serialized</code>）。</p></li> <li><p>用 HEX Fiend 打开 <code>DSDT.aml</code>（本教程的示例是 <code>SSDT-1-CB-01.aml</code>）</p> <ul><li><p>同时按住 <code>command</code> + <code>F</code> 调出搜索框，切换到 <code>Text</code> 模式，输入要更名的 Method 名字。</p></li> <li><p>切换到 <code>HEX</code> 模式，此时刚刚输入的名字已经变成了十六进制代码，接下来我们需要在后面加上方法规则代码（参数个数+是否可序列   化），对应关系如下：</p> <ul><li><p><code>Method(xxxx,a,N)</code> --&gt; <code>xxxx</code> 的十六进制代码 + <code>a</code> 的十六进制代码，最后两位范围为 <code>00</code> - <code>07</code></p></li> <li><p><code>Method(xxxx,b,S)</code> --&gt; <code>xxxx</code> 的十六进制代码 + (<code>b+8</code>) 的十六进制代码，最后两位范围为 <code>08</code> - <code>0F</code></p></li> <li><p>示例：</p> <div class="language-text extra-class"><pre class="language-text"><code>Method (MHPF,1,N) --&gt; `4D485046 01`
Method (BTST,2,S) --&gt; `42545354 0A`
</code></pre></div></li></ul></li> <li><p>在输入上述方法定义的完整十六进制代码后，按 Next 或 Previous 进行全文搜索，一般只会出现一个结果，该结果就是我们在 MaciASL 编辑器里面看到的原始方法定义。</p></li> <li><p>我们需要该方法更名为一个未被利用的名称，通常习惯以 <code>X</code> 替换第一个字母，只要不出现重复定义即可。</p></li> <li><p>切换回 <code>Text</code> 模式，将第一位改为 <code>X</code>，并再次切换为 <code>HEX</code> 模式，可以发现 <code>X</code> 对应的十六进制代码为 <code>58</code>，以后我们可以凭经验直接在 <code>HEX</code> 模式下修改。再次搜索，如果没有结果，证明该方法名没有被利用过，可以用于更名。</p></li> <li><p>当然如果要更名的 <code>Method</code> 里面存着多个除了第一位不一样其它三位一样情况时，也很容易应对，分别更名为 <code>X</code> 开头的和 <code>Y</code> 开头的就行，只要不出现重名的情况都是可以的，也就是说除了要避免与现有 <code>Method</code> 重名以外，也要避免更名后出现重名的情况。</p></li></ul></li> <li><p>例如 <code>BTST,2,S</code> 更名为 <code>XTST,2,S</code> 最终 config 的更名应填：</p> <div class="language-text extra-class"><pre class="language-text"><code>Comment      change BTST,2,S to XTST
Find         42545354 0A
Replace      58545354 0A
</code></pre></div></li></ol> <h3 id="检查mutex是否已经置0"><a href="#检查mutex是否已经置0" class="header-anchor">#</a> 检查Mutex是否已经置0</h3> <p>引用Rehabman大神的原话：</p> <blockquote><p>Some DSDTs use Mutex objects with non-zero a SyncLevel.  Evidently, OS X has some difficulty with this part of the ACPI spec, either that or the DSDTs are, in fact, codec incorrectly and Windows is ignoring it.</p> <p>The common result of a non-zero SyncLevel is failure of methods at the point of Acquire on the mutext in question.  This can result in strange behavior, failed battery status, or other issues.</p></blockquote> <p>结合ACPI规范，我的理解如下（若用语有误请指出）：</p> <blockquote><p>有些机器的 <code>Mutex</code>（互斥体，用于处理多线程同步）对象的 <code>SyncLevel</code>（同步等级）不为 <code>0</code> ，而这种情况下 macOS 无法正常执行多线程同步，造成的结果是电池状态等可能无法获取（如果电池相关的 Method 处于不同的同步等级，在 macOS 下会造成数据获取的异常，出现 0% 的情况），此时应打上 <code>Mutex</code> 置 <code>0</code> 补丁来解决</p> <p>目前所知道的绝大多数笔记本 ACPI 的 <code>Mutex</code> 都是默认置 <code>0</code> 的，但是对于一些联想品牌的笔记本，它们往往有几个 <code>Mutex</code> 的 <code>SyncLevel</code> 并不是 <code>0</code>，我们在完成电池补丁后应检查 <code>Mutex</code> 是否属于这种情况。OpenCore 没有 CLOVER 那样方便的补丁选项能直接将所有 <code>Mutex</code> 对象的同步等级修改为 <code>0</code>，这里我们需要利用 ACPI 二进制更名的方法实现置 <code>0</code>。</p></blockquote> <p><strong>具体方法如下</strong>：</p> <ul><li><p>在当前使用的 DSDT 文件里搜索 <code>Mutex</code>，看出现的几个对象的 <code>SyncLevel</code> 是否为 <code>0</code></p></li> <li><p>以 <code>Mutex (BATM, 0x07)</code> 为例，先转换BATM为十六进制代码，得到 <code>42 41 54 4D</code></p></li> <li><p>在前后加上完整定义的十六进制代码，最终得到 <code>01 42 41 54 4D 07</code></p></li> <li><p>其中 <code>01</code> 代表 <code>Mutex</code>; <code>07</code> 则代表 <code>SyncLevel</code> 的 <code>0x07</code>，</p></li> <li><p>我们的目的是使 <code>Mutex</code> 对象置 <code>0</code>，所以 config 的更名应填</p> <div class="language-text extra-class"><pre class="language-text"><code>Comment       Set Mutex BATM, 0x07 to 0x0
Find          01 42 41 54 4D 07
Repalce       01 42 41 54 4D 00
</code></pre></div></li></ul> <p>其它 <code>Mutex</code> 对象按照同样的方法处理即可。</p> <h2 id="acpi-特殊处理方案集合"><a href="#acpi-特殊处理方案集合" class="header-anchor">#</a> ACPI 特殊处理方案集合</h2> <h3 id="惠普笔记本-acel-设备禁止"><a href="#惠普笔记本-acel-设备禁止" class="header-anchor">#</a> 惠普笔记本 ACEL 设备禁止</h3> <p><strong>问题描述</strong>：由于部分惠普笔记本配备机械硬盘防护传感器，该设备实际为一个加速度传感器，即便没有驱动也能保持运行，持续向 EC 中读写数据，导致电池状态刷新异常</p> <p><strong>解决方案</strong>：在 Windows 下已经确认该设备 ACPI 名称为 ACEL，通过 ACPI 更名其 <code>_STA</code>，并在热补丁中要求 macOS 下禁止该设备</p> <h3 id="ecrd-和-ecwt-读写控制"><a href="#ecrd-和-ecwt-读写控制" class="header-anchor">#</a> ECRD 和 ECWT 读写控制</h3> <p><strong>问题描述</strong>：部分机器的 ACPI 对于 EC 作用域下的寄存器读写有严格控制，有时我们需要稍微修改一下其中的代码解除一些限制</p> <p><strong>解决方案</strong>：目前使用的方法未在多数机器上验证，暂时不给出相关方案，请等待后续更新</p> <h2 id="双电池系统解决方案"><a href="#双电池系统解决方案" class="header-anchor">#</a> 双电池系统解决方案</h2> <p>双电池系统通常分为两种情况：</p> <ul><li>第一种：只安装了一块电池，并且也没打算再装一块，这种最容易解决，利用 ACPI 更名另一块电池设备的 ACPI _STA 方法；</li> <li>第二组：安装了两块电池，并希望 macOS 下都可使用。这种情况需要更改两块电池设备的 ACPI _HID 名称使其保持运行的情况下不被电池驱动识别，同时新建一个 <code>BATC</code> 设备用于合并计算两块电池的信息和状态，代替原来两块电池设备的代码为驱动提供信息</li></ul> <p>参考链接：</p> <ul><li><a href="https://github.com/RehabMan/OS-X-ACPI-Battery-Driver" target="_blank" rel="noopener noreferrer">Rehabman's ACPI Battery Driver<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://github.com/daliansky/OC-little/tree/master/08-%E7%94%B5%E6%B1%A0%E8%A1%A5%E4%B8%81/08-1-Thinkpad" target="_blank" rel="noopener noreferrer">OC-little ThinkPad双电池系统处理<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul> <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2> <h3 id="一些经验"><a href="#一些经验" class="header-anchor">#</a> 一些经验</h3> <ul><li>对于没有用到的工具方法，可以从补丁中移除，减少补丁代码，例如 <code>W16B</code> 和 <code>WECB(WE1B)</code> 这类写入操作有些机器的 ACPI 不需要。</li> <li>大多数调用的情况都是属于读取操作，而写入操作很少。</li> <li>根据经验，同一个超过 32 位的字段单元通常只会被调用一次，尽管有些机器存在2次调用的情况，但分析代码可知，通常这两种调用不会同时进行（常见情况为当既有读取又有写入时，两种操作被控制语句限制只执行其中一种）。</li> <li>根据经验观察，并非所有涉及到字段单元拆分的 <code>Method</code> 都需要修改代码，事实上，有些 <code>Method</code> 和电池没有太大的关系，即使不对其调用的超过 8 位字段单元进行拆分也没有影响，但是为了保险起见我们还是选择了全部进行拆分修改。如果你能深入了解电池 ACPI 的读写原理，明确真正和电池相关的 <code>Method</code>，你能很轻松地从你的补丁中移除一些无关紧要的代码修改和二进制更名，最简化你的补丁，关于这方面的内容，需要一定的经验且较为深入的理解 ACPI 才能做到。</li> <li>极少数笔记本可能根本就搜不到 <code>PNP0C09</code>（<code>EC</code> 的 <code>_HID</code>），这种情况下我们只能搜 <code>PNP0C0A</code>（电池的 <code>_HID</code>），并根据 <code>_BIF</code>、<code>_BST</code>、<code>_BIX</code> 等电池 ACPI 方法入手，分析它调用的寄存器和函数，最终找到所有电池相关寄存器所在的 <code>Field</code> 内的定义（即偏移量和长度），然后根据本教程的方法进行修改，通常这类机器的 ACPI 使用的 <code>SystemMemory</code> 作用域，请务必注意起始偏移量的修正，寄存器拆分函数结尾处已经提到。</li></ul> <h3 id="如何排查错误"><a href="#如何排查错误" class="header-anchor">#</a> 如何排查错误</h3> <ul><li>当我们完成了所有的电池补丁后如果发现电池还是未能正确显示怎么办呢？
<ul><li>这种情况通常是由于我们在制作补丁没有充分考虑重名情况导致的。</li> <li>打开 Hackintool，切换到日志选项卡，选择系统，点击下方的刷新按钮生成，搜索 <code>ACPI Error</code>，看是否出现了和 <code>EC</code> 相关的错误，如果有，那么极有可能是出现了重复定义造成的，这时候我们需要修改我们电池补丁中相关对象的名称避免重名。</li></ul></li> <li>如果出现电池在拔下外置电源的情况下变红该怎么办？
<ul><li>这种情况同样需要排查 <code>ACPI Error</code>，通常这是由于其它 SSDT 缺失或者冲突造成 AC 适配器代码部分发生了异常，利用终端的 <code>grep</code> 命令在整个 <code>origin</code> 目录进行搜索一般能准确定位到问题，具体方法这里不作介绍，相对来说还是比较简单的。</li></ul></li></ul> <h2 id="参考来源"><a href="#参考来源" class="header-anchor">#</a> 参考来源</h2> <ul><li>Guide using clover to hotpatch acpi and battery status hotpatch <a href="https://github.com/rehabman" target="_blank" rel="noopener noreferrer">@Rehabman<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li>tonymacx86, PCBeta 远景黑苹果论坛, 黑果小兵的部落阁</li> <li>ACPI Specification 6.1</li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/hackintosh_advanced/ACPI_Hotpatch_Overview.html" class="prev">
        ACPI 热补丁概述
      </a></span> <span class="next"><a href="/hackintosh_advanced/Laptop_I2C_Device_GPIO.html">
        笔记本 I2C 触摸设备 GPIO 中断实现教程
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.132a4ad5.js" defer></script><script src="/assets/js/2.95e26bf5.js" defer></script><script src="/assets/js/8.5445c4e2.js" defer></script>
  </body>
</html>
