(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{207:function(t,a,s){"use strict";s.r(a);var e=s(28),v=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"acpi-热补丁概述"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#acpi-热补丁概述"}},[t._v("#")]),t._v(" ACPI 热补丁概述")]),t._v(" "),s("h2",{attrs:{id:"什么是-acpi-热补丁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是-acpi-热补丁"}},[t._v("#")]),t._v(" 什么是 ACPI 热补丁")]),t._v(" "),s("p",[t._v("通过引导程序对本机的 "),s("code",[t._v("ACPI")]),t._v(" 表二进制内容进行更名，实现禁用 "),s("code",[t._v("ACPI")]),t._v(" 表中某个设备（"),s("code",[t._v("Device")]),t._v("）下的方法（"),s("code",[t._v("Method")]),t._v("）或者变量名，同时新建 SSDT 补丁重写相关代码，达到重定义的作用")]),t._v(" "),s("h2",{attrs:{id:"acpi-热补丁通常用于哪些地方"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#acpi-热补丁通常用于哪些地方"}},[t._v("#")]),t._v(" ACPI 热补丁通常用于哪些地方")]),t._v(" "),s("ul",[s("li",[s("code",[t._v("EmbeddedControl")]),t._v("（嵌入式控制器）：该 "),s("code",[t._v("ACPI")]),t._v(" 设备下通常具备电池、光线传感器、加速度传感器、"),s("code",[t._v("EC Query")]),t._v(" 方法映射等定义")]),t._v(" "),s("li",[s("code",[t._v("I2C")]),t._v(" 总线：该 "),s("code",[t._v("ACPI")]),t._v(" 设备下通常具备触摸设备及人体学输入设备相关传感器（如指纹传感器）定义")]),t._v(" "),s("li",[t._v("睡眠唤醒相关修复："),s("code",[t._v("PNP0C0E")]),t._v("（睡眠按钮）、"),s("code",[t._v("PNP0C0D")]),t._v("（笔记本盖子）、"),s("code",[t._v("_PTS")]),t._v("（睡眠前执行）、"),s("code",[t._v("_WAK")]),t._v("（唤醒后执行）")])]),t._v(" "),s("h2",{attrs:{id:"acpi-热补丁方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#acpi-热补丁方法"}},[t._v("#")]),t._v(" ACPI 热补丁方法")]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),s("p",[t._v("热补丁的本质还是实现对 ACPI 某个设备或者方法的重定义，以便与 macOS 兼容")])]),t._v(" "),s("ul",[s("li",[s("p",[t._v("第一步，更名")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("更名通常是针对 "),s("code",[t._v("Method")]),t._v(" 来使用的，它在 "),s("code",[t._v("ACPI")]),t._v(" 中的定义与 "),s("code",[t._v("HEX")]),t._v(" 代码对应关系如下：")]),t._v(" "),s("ul",[s("li",[s("code",[t._v("Method(xxxx,a,N)")]),t._v(" --\x3e "),s("code",[t._v("xxxx")]),t._v(" 的十六进制代码 + "),s("code",[t._v("a")]),t._v(" 的十六进制代码，最后两位范围为 "),s("code",[t._v("00")]),t._v(" - "),s("code",[t._v("07")])]),t._v(" "),s("li",[s("code",[t._v("Method(xxxx,b,S)")]),t._v(" --\x3e "),s("code",[t._v("xxxx")]),t._v(" 的十六进制代码 + ("),s("code",[t._v("b+8")]),t._v(") 的十六进制代码，最后两位范围为 "),s("code",[t._v("08")]),t._v(" - "),s("code",[t._v("0F")])])])]),t._v(" "),s("li",[s("p",[t._v("根据上述关系，给出如下示例：")]),t._v(" "),s("div",{staticClass:"language-text extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("  Method (MHPF,1,N) --\x3e `4D485046 01`\n  Method (BTST,2,S) --\x3e `42545354 0A`\n")])])])]),t._v(" "),s("li",[s("p",[t._v("为了使原来的方法失效，我可以把 MHPF 更名为 XHPF，X 对应的 HEX 代码是 58，则完整的更名示例如下")]),t._v(" "),s("div",{staticClass:"language-text extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("Comment change MHPF,1,N to XHPF\nFind    4D485046 01\nRplace  58485046 01\n")])])])])])]),t._v(" "),s("li",[s("p",[t._v("第二步，重定义")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("在建立的 SSDT 补丁中，将已经更名的原始代码复制过来，并按照需求进行改动")])]),t._v(" "),s("li",[s("p",[t._v("补充上操作系统判断，使整个热补丁只在 macOS 下生效，示例格式如下")]),t._v(" "),s("div",{staticClass:"language-Swift extra-class"},[s("pre",{pre:!0,attrs:{class:"language-swift"}},[s("code",[s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("Method")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("MHPF")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("NotSerialized")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("If")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("_OSI")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Darwin"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        ···\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("XHPF")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("Arg0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])])]),t._v(" "),s("li",[s("p",[t._v("备注：若原来的 "),s("code",[t._v("Method")]),t._v(" 定义了参数，则在回调时应该加上参数；若原来的代码存在 "),s("code",[t._v("Return")]),t._v(" 语句，则回调时应该以 "),s("code",[t._v("Return")]),t._v(" 的形式回调原始代码")])])])])]),t._v(" "),s("div",{staticClass:"custom-block warning"},[s("p",{staticClass:"custom-block-title"},[t._v("注意事项")]),t._v(" "),s("p",[t._v("当 ACPI 更名涉及到 "),s("code",[t._v("_STA")]),t._v("、"),s("code",[t._v("_CRS")]),t._v(" 等在原始 ACPI 中反复出现的方法时，若使用的是 CLOVER 引导，则可以利用 TgtBridge 限定修改区域；若使用的是 OpenCore 引导，则需要使用 skip 和 count 计数方法来精确定位到需要修改的地方，这种方法难度较大，可以考虑采取拉长 HEX 代码的方法确保唯一性（利用 HEXFriend 在 ACPI 中找到你需要更名的那段代码然后将其上下文包含进来进行搜索确认是否是唯一的）")])])])}),[],!1,null,null,null);a.default=v.exports}}]);